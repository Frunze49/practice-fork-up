# fuzzing json-basalaev by ershov

## Как запускать:

```bash
cd practice/09-fuzz/json-basalaev-ershov/
clang++ -g -fsanitize=fuzzer,address fuzz_me.cc
./a.out -max_len=10000
```

В решении `json-basalaev` входные и выходные данные подаются через файлики, поэтому при фаззинге входные сгенерированные данные кладутся в файлик. Из-за этого фаззинг не параллелится.  

Я попытался сделать решение параллельным, каждый раз создавая tmp файлики, но тут уже начало у меня стрелять мои проблемы с файловой системой, вероятно вызванной слишком большим количеством одновремнно открытых файлов. К тому же такое решение не гарантирует, что в двух разных процессах будет сгенерировано два разных названия у tmp файла.

## Какие проблемы в решении были найдены:

- в местах, где вызывается `fopen`, не вызывается `fclose`. Из-за этого решение иногда падает из-за `read access`
- изначально был `json-basalaev.cpp`, в которым определен `main`. Убрал `main` и переименовал в `json-basalaev.h`

## Как был реализован фаззинг

опишу какие файлики используются для фаззинга

### Сам код, запускающий фаззинг -- `fuzz_me.cc`. 

Тут всё просто, принимаются сырые данные, они проверяются на корректности относительно условия задачи. Дальше последовательно вызываются `covertBinaryToJson` и `convertJsonToBinary`. В конце сравнивается, что полученный бинарник совпадает с изначально сгенерирвоанными данными

### Код, проверяющий корректность данных -- `precheck.h`

Основная сложность была в том, чтобы проверить, что бинарные данные можно конвертировать в utf-8. Такое требование исходит из сохранения строк в json полях. 

Изначально пробовал воспользоваться `std::codecvt_utf8`, где я просто бы ловил ошибку при конвертации (Если ошибки нет, то конвертировать можно, если есть -- то нельзя). Однако `std::codecvt_utf8` является deprecated как раз по причине того, что она не покрывает всё разнообразие конвертации utf-8. В частности решение `std::codecvt_utf8` полечило мне часть проблем, но все равно проблема с конвертацией осталась.

Дальше я решил проблему другим способом: проверка на конвертацию есть в самом `json.hpp`. Я решил при проверке данных пытаться запихивать данные в json формат. Таким образом, при проверке сгенерированных данных я явно проверю, что их можно положить в json.